#Project: Visualise hidden layers in features

# Goal: You can choose which layor to observe

import torch
import torch.nn as nn
import torchvision
from torchvision import models, transforms, utils
from torch.autograd import Variable
import numpy as np
import matplotlib.pyplot as plt
#import scipy.misc        #Consider removing this
from PIL import Image
import json
import gradio as gr
import os
#matplotlib inline

#Defining image transformations
transform = transforms.Compose([
    transforms.Resize((224, 224)),
    transforms.ToTensor(),
    transforms.Normalize(mean=0., std=1.)
])

def cnn(im, layorNumber):
    #Loading the image
    image = Image.open(str(im))
    plt.imshow(image)

    #Load in pretrained model
    model = models.resnet18(pretrained=True)
    print(model)

    #Extracting layers and names
    #--------------------------------
    # we will save the conv layer weights in this list
    model_weights =[]
    #we will save the 49 conv layers in this list
    conv_layers = []
    # get all the model children as list
    model_children = list(model.children())
    #counter to keep count of the conv layers
    counter = 0
    #append all the conv layers and their respective wights to the list
    for i in range(len(model_children)):
        if type(model_children[i]) == nn.Conv2d:
            counter+=1
            model_weights.append(model_children[i].weight)
            conv_layers.append(model_children[i])
        elif type(model_children[i]) == nn.Sequential:
            for j in range(len(model_children[i])):
                for child in model_children[i][j].children():
                    if type(child) == nn.Conv2d:
                        counter+=1
                        model_weights.append(child.weight)
                        conv_layers.append(child)
    print(f"Total convolution layers: {counter}")
    print("conv_layers")

    #GPU check
    device = torch.device('cpu')
    model = model.to(device)

    #Image transformation
    image = transform(image)
    print(f"Image shape before: {image.shape}")
    image = image.unsqueeze(0)
    print(f"Image shape after: {image.shape}")
    image = image.to(device)

    #Feature map generation
    outputsThis = []                     #This is what we are indexing
    names = []                           #This is what the user should select from
    for layer in conv_layers[0:]:
        image = layer(image)
        outputsThis.append(image)
        names.append(str(layer))
    print(len(outputsThis))
    #print feature_maps
    for feature_map in outputsThis:
        print(feature_map.shape)
    
    #3D to 2D tensor
    processed = []
    for feature_map in outputsThis:
        feature_map = feature_map.squeeze(0)
        gray_scale = torch.sum(feature_map,0)
        gray_scale = gray_scale / feature_map.shape[0]
        processed.append(gray_scale.data.cpu().numpy())
    for fm in processed:
        print(fm.shape)

    #Plot features
    for i in range(len(processed)):
        #generate images here

    #this to jpg ... outputsThis[int(layorNumber)]
    # Create figure out of each layor and itterate through them

#Below pertains to gradio interface

with gr.Blocks() as demo:

    layorNumber = gr.Textbox(label="Input layor number", lines=2)

    with gr.Row():
        im = gr.Image()
        im2 = gr.Image()

    btn = gr.Button(value="Select Image")
    btn.click(cnn, inputs=[im,layorNumber], outputs=[im2])

if __name__ == "__main__":
    demo.launch()
    